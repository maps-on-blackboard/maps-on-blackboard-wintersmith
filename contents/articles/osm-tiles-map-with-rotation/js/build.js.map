{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "js/main.js",
    "node_modules/map-the-tiles/map-the-tiles.js",
    "node_modules/map-the-tiles/node_modules/rectangles-intersect/node_modules/check-point-in-rectangle/check-point-in-rectangle.js",
    "node_modules/map-the-tiles/node_modules/rectangles-intersect/node_modules/line-segments-intersect/line-segments-intersect.js",
    "node_modules/map-the-tiles/node_modules/rectangles-intersect/rectangles-intersect.js",
    "node_modules/map-the-tiles/node_modules/transformatrix/index.js",
    "node_modules/sphericalmercator/sphericalmercator.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var Tiler = require('map-the-tiles'),\n  SphericalMercator = require('sphericalmercator'),\n  baseURL = 'http://tile.openstreetmap.org',\n  tilesContainerDiv, size, merc, tiler;\n\n// get map window size\ntilesContainerDiv = document.getElementById('tilesContainer');\nsize = {\n  height: parseInt(tilesContainerDiv.clientHeight),\n  width: parseInt(tilesContainerDiv.clientWidth)\n};\n// instance of 'map-the-tiles'\ntiler = new Tiler(size);\n// projection tranformer instace\nmerc = new SphericalMercator({size:256});\n// add event listenre to 'zoomTo' button \ndocument.getElementById('zoomTo').addEventListener('click', zoomTo);\n// call zoomTo funcion on page load\nzoomTo();\n\nfunction zoomTo() {\n  var center = document.getElementById('center').value.split(','),\n    zoom =  parseInt(document.getElementById('zoom').value),\n    rotation = parseFloat(document.getElementById('rotation').value),\n    mercCenter, tiles;\n  // calculate map parameters in mercator projection\n  mercCenter = merc.forward([parseFloat(center[0]),parseFloat(center[1])]);\n \n  // get map tiles list for our map extent\n  tiles = tiler.getTiles(mercCenter, zoom,rotation);\n  tilesContainerDiv.style.transform = 'rotate('+(rotation)+'deg)';\n  // append map tile images to the map div\n  tilesContainerDiv.innerHTML = \"\";\n  tiles.forEach(function(t) {\n    var img = document.createElement('img');\n    img.src = baseURL + '/'+ t.z + '/' + t.x + '/' + t.y + '.png';\n    img.setAttribute('style', 'left:'+ t.left + 'px;top:'+t.top+'px;');\n    img.setAttribute('class','tile');\n    tilesContainerDiv.appendChild(img);\n  });\n}\n",
    "// map-the-tiles.js\nvar TransformMatrix = require('transformatrix'),\n  intersect = require('rectangles-intersect');\nvar MapTheTiles = function (viewportSize,projExtent,tileSize) {\n  this.vpSize = viewportSize || {width: 256, height: 256};\n  // default spherical mercator project extent\n  this.projExtent = projExtent || { \n    left: -20037508.342789244,\n    right: 20037508.342789244,\n    bottom: -20037508.342789244,\n    top: 20037508.342789244\n  };\n  this.tSize = tileSize || 256;\n  this.maxRes = Math.min(\n    Math.abs(this.projExtent.right - this.projExtent.left)/this.tSize,\n    Math.abs(this.projExtent.top - this.projExtent.bottom)/this.tSize);\n}\nMapTheTiles.prototype.getTiles = function(ctr, z, rot) {\n  // all calculation are in pixel coordinates i.e. project extent devied by \n  // resolution at that zoom level\n  if(!Array.isArray(ctr)) {\n    ctr = [ctr.x,ctr.y];\n  }\n  var vpExtPx = this._getExtentPx(ctr,z), //view port extent in pixel\n    ctrPx = this._pointToPx(ctr,z), //center in pixel\n    tr, // instance of TransformMatrix used for rotated view calculation\n    rotViewportPx, // rotated view port corner coordinates in pixel\n    // expandedExtPx: rotated view port extent (MBR) in pixel, if rotation \n    // is 0 then equals to view port extent\n    expandedExtPx = vpExtPx,\n    xLeft, xRight, yBottom, yTop, top, left,\n    tiles = [];\n  if(rot && rot !=0) {\n    rot = -rot; //to follow the HTML (transform) convention clockwise positive\n    tr = new TransformMatrix();\n    tr.translate(ctrPx[0], ctrPx[1]);\n    tr.rotate(Math.PI/180 * rot); //as rot is in deg\n    tr.translate(-ctrPx[0], -ctrPx[1]);\n    rotViewportPx = [\n      tr.transformPoint(vpExtPx.left,vpExtPx.bottom),\n      tr.transformPoint(vpExtPx.right,vpExtPx.bottom),\n      tr.transformPoint(vpExtPx.right,vpExtPx.top),\n      tr.transformPoint(vpExtPx.left,vpExtPx.top)\n    ];\n    expandedExtPx = getBBox(rotViewportPx);\n  }\n  // tile numbers\n  xLeft = Math.floor(expandedExtPx.left/this.tSize);\n  xRight = Math.floor(expandedExtPx.right/this.tSize);\n  yBottom = Math.floor(expandedExtPx.bottom/this.tSize);\n  yTop = Math.floor(expandedExtPx.top/this.tSize);\n  //top left tile position of top-left tile with respect to window/div \n  top = topStart = Math.round((yTop * this.tSize) - vpExtPx.top);\n  left = Math.round((xLeft * this.tSize) - vpExtPx.left);\n  for (var i=xLeft; i<=xRight; i++) {\n    top = topStart;\n    for(var j=yTop; j<=yBottom; j++) {\n      tiles.push({x:i, y:j, z:z, top: top, left: left});\n      top += this.tSize;\n    }\n    left += this.tSize;\n  }\n  if(rot && rot != 0) {\n    // filters out tiles (from expanded view port) that do not intersect with\n    // view port \n    tiles = tiles.filter(function(t) {\n      return intersect(rotViewportPx,this._getTileBoundingRect(t));\n    },this);\n  }\n  return tiles;\n};\n\nMapTheTiles.prototype._getExtentPx = function(ctr,z) {\n  var res = this.maxRes/Math.pow(2,z);\n  return {\n    left: (ctr[0] - this.projExtent.left)/res - this.vpSize.width/2,\n    right: (ctr[0] - this.projExtent.left)/res + this.vpSize.width/2,\n    bottom: (this.projExtent.top - ctr[1])/res + this.vpSize.height/2,\n    top: (this.projExtent.top - ctr[1])/res - this.vpSize.height/2\n  };\n};\nMapTheTiles.prototype._pointToPx = function(pt,z) {\n  var res = this.maxRes/Math.pow(2,z);\n  return [\n    (pt[0] - this.projExtent.left)/res,\n    (this.projExtent.top - pt[1])/res\n  ];\n};\nMapTheTiles.prototype._getTileBoundingRect = function(t) {\n  var res, l, r, t, b;\n  res = this.maxRes/Math.pow(2,t.z);\n  l = t.x * this.tSize;\n  r = l + this.tSize;\n  t = t.y * this.tSize;\n  b = t + this.tSize;\n  return [[l,b], [r,b], [r,t], [l,t]];\n};\nfunction getBBox(points) {\n  var xArray = points.map(function(p) {return p[0];});\n  var yArray = points.map(function(p) {return p[1];});\n  return {\n    left: Math.min.apply(this,xArray),\n    right: Math.max.apply(this,xArray),\n    bottom: Math.max.apply(this,yArray),\n    top: Math.min.apply(this,yArray)\n  };\n}\nmodule.exports = MapTheTiles;\n",
    "// check-point-in-rectangle.js\n// check point intersects with rectangle\n// http://martin-thoma.com/how-to-check-if-a-point-is-inside-a-rectangle/\nfunction pointInRect(pt,rect,precision) {\n  var p = precision || 6;\n  var rectArea = 0.5*Math.abs(\n    (rect[0][1] - rect[2][1]) * (rect[3][0] - rect[1][0])\n    + (rect[1][1] - rect[3][1]) * (rect[0][0] - rect[2][0])\n  );\n  var triangleArea = rect.reduce(function(prev,cur, i, arr) {\n    var j = i == arr.length-1 ? 0 : i+1;\n    return prev + 0.5*Math.abs(\n      pt[0] * (arr[i][1] - arr[j][1])\n      + arr[i][0] * (arr[j][1] - pt[1])\n      + arr[j][0] * (pt[1] - arr[i][1])\n    );\n  }, 0);\n  return fix(triangleArea,p) == fix(rectArea,p);\n}\n// fix to the precision\nfunction fix(n,p) {\n  return parseInt(n * Math.pow(10,p));\n};\n\nmodule.exports = pointInRect;\n",
    "// line-segments-intersect.js \n// intersection point https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n// line 1: x1,y1,x2,y2\n// line 2: x3,y3,x4,y4\n// for comparing the float number, fixing the number to int to required \n// precision\nfunction linesIntersect(seg1, seg2, precision) {\n  var x1 = seg1[0][0],\n    y1 = seg1[0][1],\n    x2 = seg1[1][0],\n    y2 = seg1[1][1],\n    x3 = seg2[0][0],\n    y3 = seg2[0][1],\n    x4 = seg2[1][0],\n    y4 = seg2[1][1],\n    intPt,x,y,result = false, \n    p = precision || 6,\n    denominator = (x1 - x2)*(y3 - y4) - (y1 -y2)*(x3 - x4);\n  if (denominator == 0) {\n    // check both segments are Coincident, we already know \n    // that these two are parallel \n    if (fix((y3 - y1)*(x2 - x1),p) == fix((y2 -y1)*(x3 - x1),p)) {\n      // second segment any end point lies on first segment\n      result = intPtOnSegment(x3,y3,x1,y1,x2,y2,p) ||\n        intPtOnSegment(x4,y4,x1,y1,x2,y2,p);\n    }\n  } else {\n    x = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4))/denominator;\n    y = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4))/denominator;\n    // check int point (x,y) lies on both segment \n    result = intPtOnSegment(x,y,x1,y1,x2,y2,p) \n      && intPtOnSegment(x,y,x3,y3,x4,y4,p);\n  }\n  return result;\n} \n\nfunction intPtOnSegment(x,y,x1,y1,x2,y2,p) {\n  return fix(Math.min(x1,x2),p) <= fix(x,p) && fix(x,p) <= fix(Math.max(x1,x2),p) \n    && fix(Math.min(y1,y2),p) <= fix(y,p) && fix(y,p) <= fix(Math.max(y1,y2),p); \n}\n\n// fix to the precision\nfunction fix(n,p) {\n  return parseInt(n * Math.pow(10,p));\n}\n\nmodule.exports = linesIntersect;\n",
    "// rectangles-intersect.js\n// two rectangles (non aligned to axis) intersects or not\nvar linesIntersect = require('line-segments-intersect'),\n  pointInside = require('check-point-in-rectangle');\n\nfunction intersects(rect1,rect2) {\n  var intersect = rect1.some(function(pt1,i,r1) {\n    //check intersection of any seg or rect1 to any seg of rect2\n    var j = i == r1.length-1 ? 0 : i+1;\n    return rect2.some(function(pt2,k,r2) {\n      var l = k == r2.length-1 ? 0 : k+1;\n      return linesIntersect([r1[i], r1[j]], [r2[k], r2[l]]);\n    });\n  });\n  if(!intersect) {\n    // check one rectangle contains another\n    intersect = rect2.some(function(pt) {\n      return pointInside(pt, rect1);\n    }) ||\n    rect1.some(function(pt) {\n      return pointInside(pt, rect2);\n    });\n  }\n  return intersect;\n}\n\nmodule.exports = intersects;\n",
    "var Matrix = function() {\n    this.reset();\n};\nMatrix.prototype.reset = function() {\n    this.m = [1, 0, 0, 1, 0, 0];\n    return this;\n};\nMatrix.prototype.multiply = function(matrix) {\n    var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1],\n        m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1],\n        m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3],\n        m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];\n\n    var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4],\n        dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n    this.m[4] = dx;\n    this.m[5] = dy;\n    return this;\n};\nMatrix.prototype.inverse = function() {\n    var inv = new Matrix();\n    inv.m = this.m.slice(0);\n    var d = 1 / (inv.m[0] * inv.m[3] - inv.m[1] * inv.m[2]),\n        m0 = inv.m[3] * d,\n        m1 = -inv.m[1] * d,\n        m2 = -inv.m[2] * d,\n        m3 = inv.m[0] * d,\n        m4 = d * (inv.m[2] * inv.m[5] - inv.m[3] * inv.m[4]),\n        m5 = d * (inv.m[1] * inv.m[4] - inv.m[0] * inv.m[5]);\n    inv.m[0] = m0;\n    inv.m[1] = m1;\n    inv.m[2] = m2;\n    inv.m[3] = m3;\n    inv.m[4] = m4;\n    inv.m[5] = m5;\n    return inv;\n};\nMatrix.prototype.rotate = function(rad) {\n    var c = Math.cos(rad),\n        s = Math.sin(rad),\n        m11 = this.m[0] * c + this.m[2] * s,\n        m12 = this.m[1] * c + this.m[3] * s,\n        m21 = this.m[0] * -s + this.m[2] * c,\n        m22 = this.m[1] * -s + this.m[3] * c;\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n    return this;\n};\nMatrix.prototype.translate = function(x, y) {\n    this.m[4] += this.m[0] * x + this.m[2] * y;\n    this.m[5] += this.m[1] * x + this.m[3] * y;\n    return this;\n};\nMatrix.prototype.scale = function(sx, sy) {\n    this.m[0] *= sx;\n    this.m[1] *= sx;\n    this.m[2] *= sy;\n    this.m[3] *= sy;\n    return this;\n};\nMatrix.prototype.transformPoint = function(px, py) {\n    var x = px,\n        y = py;\n    px = x * this.m[0] + y * this.m[2] + this.m[4];\n    py = x * this.m[1] + y * this.m[3] + this.m[5];\n    return [px, py];\n};\nMatrix.prototype.transformVector = function(px, py) {\n    var x = px,\n        y = py;\n    px = x * this.m[0] + y * this.m[2];\n    py = x * this.m[1] + y * this.m[3];\n    return [px, py];\n};\nif(typeof module !== \"undefined\") {\n    module.exports = Matrix;\n}\nelse {\n    window.Matrix = Matrix;\n}\n",
    "var SphericalMercator = (function(){\n\n// Closures including constants and other precalculated values.\nvar cache = {},\n    EPSLN = 1.0e-10,\n    D2R = Math.PI / 180,\n    R2D = 180 / Math.PI,\n    // 900913 properties.\n    A = 6378137.0,\n    MAXEXTENT = 20037508.342789244;\n\n\n// SphericalMercator constructor: precaches calculations\n// for fast tile lookups.\nfunction SphericalMercator(options) {\n    options = options || {};\n    this.size = options.size || 256;\n    if (!cache[this.size]) {\n        var size = this.size;\n        var c = cache[this.size] = {};\n        c.Bc = [];\n        c.Cc = [];\n        c.zc = [];\n        c.Ac = [];\n        for (var d = 0; d < 30; d++) {\n            c.Bc.push(size / 360);\n            c.Cc.push(size / (2 * Math.PI));\n            c.zc.push(size / 2);\n            c.Ac.push(size);\n            size *= 2;\n        }\n    }\n    this.Bc = cache[this.size].Bc;\n    this.Cc = cache[this.size].Cc;\n    this.zc = cache[this.size].zc;\n    this.Ac = cache[this.size].Ac;\n};\n\n// Convert lon lat to screen pixel value\n//\n// - `ll` {Array} `[lon, lat]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.px = function(ll, zoom) {\n    var d = this.zc[zoom];\n    var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);\n    var x = Math.round(d + ll[0] * this.Bc[zoom]);\n    var y = Math.round(d + 0.5 * Math.log((1 + f) / (1 - f)) * (-this.Cc[zoom]));\n    (x > this.Ac[zoom]) && (x = this.Ac[zoom]);\n    (y > this.Ac[zoom]) && (y = this.Ac[zoom]);\n    //(x < 0) && (x = 0);\n    //(y < 0) && (y = 0);\n    return [x, y];\n};\n\n// Convert screen pixel value to lon lat\n//\n// - `px` {Array} `[x, y]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.ll = function(px, zoom) {\n    var g = (px[1] - this.zc[zoom]) / (-this.Cc[zoom]);\n    var lon = (px[0] - this.zc[zoom]) / this.Bc[zoom];\n    var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);\n    return [lon, lat];\n};\n\n// Convert tile xyz value to bbox of the form `[w, s, e, n]`\n//\n// - `x` {Number} x (longitude) number.\n// - `y` {Number} y (latitude) number.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection for resulting bbox (WGS84|900913).\n// - `return` {Array} bbox array of values in form `[w, s, e, n]`.\nSphericalMercator.prototype.bbox = function(x, y, zoom, tms_style, srs) {\n    // Convert xyz into bbox with srs WGS84\n    if (tms_style) {\n        y = (Math.pow(2, zoom) - 1) - y;\n    }\n    // Use +y to make sure it's a number to avoid inadvertent concatenation.\n    var ll = [x * this.size, (+y + 1) * this.size]; // lower left\n    // Use +x to make sure it's a number to avoid inadvertent concatenation.\n    var ur = [(+x + 1) * this.size, y * this.size]; // upper right\n    var bbox = this.ll(ll, zoom).concat(this.ll(ur, zoom));\n\n    // If web mercator requested reproject to 900913.\n    if (srs === '900913') {\n        return this.convert(bbox, '900913');\n    } else {\n        return bbox;\n    }\n};\n\n// Convert bbox to xyx bounds\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection of input bbox (WGS84|900913).\n// - `@return` {Object} XYZ bounds containing minX, maxX, minY, maxY properties.\nSphericalMercator.prototype.xyz = function(bbox, zoom, tms_style, srs) {\n    // If web mercator provided reproject to WGS84.\n    if (srs === '900913') {\n        bbox = this.convert(bbox, 'WGS84');\n    }\n\n    var ll = [bbox[0], bbox[1]]; // lower left\n    var ur = [bbox[2], bbox[3]]; // upper right\n    var px_ll = this.px(ll, zoom);\n    var px_ur = this.px(ur, zoom);\n    // Y = 0 for XYZ is the top hence minY uses px_ur[1].\n    var bounds = {\n        minX: Math.floor(px_ll[0] / this.size),\n        minY: Math.floor(px_ur[1] / this.size),\n        maxX: Math.floor((px_ur[0] - 1) / this.size),\n        maxY: Math.floor((px_ll[1] - 1) / this.size)\n    };\n    if (tms_style) {\n        var tms = {\n            minY: (Math.pow(2, zoom) - 1) - bounds.maxY,\n            maxY: (Math.pow(2, zoom) - 1) - bounds.minY\n        };\n        bounds.minY = tms.minY;\n        bounds.maxY = tms.maxY;\n    }\n    return bounds;\n};\n\n// Convert projection of given bbox.\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `to` {String} projection of output bbox (WGS84|900913). Input bbox\n//   assumed to be the \"other\" projection.\n// - `@return` {Object} bbox with reprojected coordinates.\nSphericalMercator.prototype.convert = function(bbox, to) {\n    if (to === '900913') {\n        return this.forward(bbox.slice(0, 2)).concat(this.forward(bbox.slice(2,4)));\n    } else {\n        return this.inverse(bbox.slice(0, 2)).concat(this.inverse(bbox.slice(2,4)));\n    }\n};\n\n// Convert lon/lat values to 900913 x/y.\nSphericalMercator.prototype.forward = function(ll) {\n    var xy = [\n        A * ll[0] * D2R,\n        A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * ll[1] * D2R)))\n    ];\n    // if xy value is beyond maxextent (e.g. poles), return maxextent.\n    (xy[0] > MAXEXTENT) && (xy[0] = MAXEXTENT);\n    (xy[0] < -MAXEXTENT) && (xy[0] = -MAXEXTENT);\n    (xy[1] > MAXEXTENT) && (xy[1] = MAXEXTENT);\n    (xy[1] < -MAXEXTENT) && (xy[1] = -MAXEXTENT);\n    return xy;\n};\n\n// Convert 900913 x/y values to lon/lat.\nSphericalMercator.prototype.inverse = function(xy) {\n    return [\n        (xy[0] * R2D / A),\n        ((Math.PI*0.5) - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D\n    ];\n};\n\nreturn SphericalMercator;\n\n})();\n\nif (typeof module !== 'undefined' && typeof exports !== 'undefined') {\n    module.exports = exports = SphericalMercator;\n}\n"
  ]
}